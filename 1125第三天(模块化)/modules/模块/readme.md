#将一个复杂的程序依据一定的规则(规范)封装成几个块(文件),并且进行组合在一起
#块的内部数据/实现是私有的,只是向外部暴露一些接口(方法)与外部其他模块进行通信。

模块化的真实作用：
单独的函数名：function run(){}
这样很容易出现函数名命名冲突，影响函数的使用。

=====
js的垃圾回收机制：
在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。

闭包：
定义在函数中的函数，并且外层函数的返回值是内层函数的函数名。

作用是：
能够将变量保存在内存中。并且在闭包的父级外面读取和修改闭包变量的值。

需要注意的问题：
（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

=====
函数参数的传递：
```
如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的是原始值的地址，因此在函数内部修改参数，将会影响到原始值。
举个栗子：
var arr = [2,5];
function Keyth(Arr){
  Arr[0] = 10;
}
Keyth(arr);
console.log(arr[0]);  //此时可以看到数组第一项的结果已经变成了3,说明在函数内部修改这些传址传递的参数会修改该参数的原始值。

但是存在这样一种情况,如果是替换参数的整体内容,那么不会影响原始值，举个栗子:
var arr1 = [2,5];
function Keyth(Arr){
  Arr = [4,7,9,1];
}
Keyth(arr1);
console.log(arr1);   //[2,5],值不发生变化



> * arguments对象：
JavaScript 中每个函数内都能访问一个特别变量 arguments。这个变量维护着所有传递到这个函数中的参数列表。

arguments 对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。
举个栗子：
function keith(a, b, c) {
      console.log(arguments[0]); //1
      console.log(arguments[2]); //3
      console.log(arguments.length); //4
  }

  keith(1, 2, 3, 4);
arguments 对象不是一个数组，它是一个类数组对象。因此，无法对 arguments 变量使用标准的数组方法，比如 push, pop 或者 slice。但是可以使用数组中的length属性。

类数组转换成真数组的方法：
var arr = Array.prototype.slice.call(arguments)

```
